<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linear Halftone Tool</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@400;500;600&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Geist Mono', 'SF Mono', Monaco, 'Cascadia Code', monospace;
            background: #000;
            color: #ededed;
            min-height: 100vh;
            font-size: 13px;
        }

        .app {
            display: grid;
            grid-template-columns: 340px 1fr;
            min-height: 100vh;
        }

        .sidebar {
            background: #000;
            padding: 24px;
            border-right: 1px solid #252525;
            overflow-y: auto;
        }

        h1 {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 4px;
            letter-spacing: -0.01em;
        }

        .subtitle {
            font-size: 13px;
            color: #666;
            margin-bottom: 32px;
        }

        .upload-zone {
            border: 1px dashed #333;
            border-radius: 8px;
            padding: 32px 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.15s ease;
            margin-bottom: 32px;
        }

        .upload-zone:hover {
            border-color: #444;
            background: rgba(255, 255, 255, 0.02);
        }

        .upload-zone.dragover {
            border-color: #648DFF;
            background: rgba(100, 141, 255, 0.05);
        }

        .upload-icon {
            font-size: 24px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .upload-text {
            font-size: 13px;
            color: #666;
        }

        .upload-text strong {
            color: #ededed;
        }

        input[type="file"] {
            display: none;
        }

        .section {
            margin-bottom: 28px;
        }

        .section-title {
            font-size: 11px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #666;
            margin-bottom: 16px;
        }

        .control {
            margin-bottom: 20px;
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .control label {
            font-size: 13px;
            color: #888;
        }

        .control-value {
            font-size: 13px;
            color: #648DFF;
        }

        input[type="range"] {
            width: 100%;
            height: 2px;
            border-radius: 1px;
            background: #252525;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #ededed;
            cursor: pointer;
            transition: all 0.15s ease;
            border: none;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #fff;
            transform: scale(1.1);
        }

        .checkbox-control {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            font-size: 13px;
            color: #888;
        }

        .checkbox-control input {
            width: 16px;
            height: 16px;
            accent-color: #648DFF;
            cursor: pointer;
            border-radius: 4px;
        }

        .export-section {
            border-top: 1px solid #252525;
            padding-top: 28px;
            margin-top: 28px;
        }

        .export-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .export-option {
            padding: 12px 8px;
            background: transparent;
            border: 1px solid #252525;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .export-option:hover {
            border-color: #333;
            background: rgba(255, 255, 255, 0.02);
        }

        .export-option.selected {
            border-color: #648DFF;
            background: rgba(100, 141, 255, 0.08);
        }

        .export-option .scale {
            font-size: 14px;
            font-weight: 500;
            color: #ededed;
        }

        .export-option .label {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }

        .export-btn {
            width: 100%;
            padding: 12px;
            background: #ededed;
            color: #000;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .export-btn:hover {
            background: #fff;
        }

        .export-btn:disabled {
            background: #1a1a1a;
            color: #444;
            cursor: not-allowed;
        }

        .canvas-area {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            background: #0a0a0a;
            position: relative;
            overflow: auto;
        }

        .canvas-container {
            position: relative;
            background: repeating-conic-gradient(#141414 0% 25%, #0a0a0a 0% 50%) 50% / 16px 16px;
            border-radius: 6px;
            overflow: hidden;
        }

        #outputCanvas {
            display: block;
            max-width: 100%;
            max-height: calc(100vh - 48px);
        }

        .placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #333;
            text-align: center;
            padding: 48px;
        }

        .placeholder-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .placeholder-text {
            font-size: 13px;
            color: #444;
        }

        .image-info {
            font-size: 12px;
            color: #444;
            margin-top: 20px;
            padding: 12px;
            background: #0a0a0a;
            border: 1px solid #252525;
            border-radius: 6px;
            line-height: 1.6;
        }

        .image-info span {
            color: #666;
        }

        .view-toggle {
            display: flex;
            background: #0a0a0a;
            border: 1px solid #252525;
            border-radius: 6px;
            padding: 3px;
            margin-bottom: 20px;
        }

        .view-btn {
            flex: 1;
            padding: 8px 12px;
            background: transparent;
            border: none;
            color: #666;
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.15s ease;
        }

        .view-btn:hover {
            color: #888;
        }

        .view-btn.active {
            background: #ededed;
            color: #000;
        }

        .zoom-controls {
            position: absolute;
            bottom: 24px;
            right: 24px;
            display: flex;
            gap: 1px;
            background: #252525;
            padding: 1px;
            border-radius: 6px;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            background: #0a0a0a;
            border: none;
            color: #888;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-family: inherit;
            transition: all 0.15s ease;
        }

        .zoom-btn:first-child {
            border-radius: 5px 0 0 5px;
        }

        .zoom-btn:last-child {
            border-radius: 0 5px 5px 0;
        }

        .zoom-btn:hover {
            background: #141414;
            color: #ededed;
        }

        .zoom-level {
            display: flex;
            align-items: center;
            padding: 0 12px;
            font-size: 12px;
            color: #666;
            background: #0a0a0a;
        }

        .processing {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .spinner {
            width: 32px;
            height: 32px;
            border: 2px solid #252525;
            border-top-color: #648DFF;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        select {
            width: 100%;
            padding: 10px 12px;
            background: #0a0a0a;
            border: 1px solid #252525;
            border-radius: 6px;
            color: #ededed;
            font-family: inherit;
            font-size: 13px;
            cursor: pointer;
            outline: none;
            transition: border-color 0.15s ease;
        }

        select:focus {
            border-color: #648DFF;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #000;
        }

        ::-webkit-scrollbar-thumb {
            background: #252525;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #333;
        }
    </style>
</head>
<body>
    <div class="app">
        <aside class="sidebar">
            <h1>Linear Halftone</h1>
            <p class="subtitle">Image → Halftone converter</p>

            <div class="upload-zone" id="uploadZone">
                <div class="upload-icon">↑</div>
                <p class="upload-text"><strong>Upload image</strong></p>
                <p class="upload-text">or drag and drop</p>
            </div>
            <input type="file" id="fileInput" accept="image/*">

            <div id="controls" class="hidden">
                <div class="section">
                    <div class="section-title">View</div>
                    <div class="view-toggle">
                        <button class="view-btn active" data-view="halftone">Halftone</button>
                        <button class="view-btn" data-view="greyscale">Greyscale</button>
                        <button class="view-btn" data-view="original">Original</button>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Background Removal</div>
                    
                    <div class="control">
                        <label class="checkbox-control">
                            <input type="checkbox" id="removeBg">
                            Remove background
                        </label>
                    </div>
                    
                    <div id="bgRemovalSettings" class="hidden">
                        <div class="control">
                            <div class="control-header">
                                <label>Sample from</label>
                            </div>
                            <select id="bgSamplePosition">
                                <option value="corners">Corners (auto)</option>
                                <option value="topleft">Top-left</option>
                                <option value="topright">Top-right</option>
                                <option value="bottomleft">Bottom-left</option>
                                <option value="bottomright">Bottom-right</option>
                            </select>
                        </div>
                        
                        <div class="control">
                            <div class="control-header">
                                <label>Tolerance</label>
                                <span class="control-value"><span id="bgToleranceValue">30</span></span>
                            </div>
                            <input type="range" id="bgTolerance" min="1" max="100" value="30">
                        </div>
                        
                        <div class="control">
                            <div class="control-header">
                                <label>Edge Softness</label>
                                <span class="control-value"><span id="bgSoftnessValue">1</span>px</span>
                            </div>
                            <input type="range" id="bgSoftness" min="0" max="5" value="1">
                        </div>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Method</div>
                    
                    <div class="control">
                        <select id="method">
                            <option value="halftone">Halftone Screen</option>
                            <option value="threshold">50% Threshold</option>
                            <option value="pattern">Pattern Dither</option>
                            <option value="diffusion">Diffusion Dither</option>
                        </select>
                    </div>
                </div>

                <div class="section" id="halftoneSettings">
                    <div class="section-title">Halftone Settings</div>
                    
                    <div class="control">
                        <div class="control-header">
                            <label>Shape</label>
                        </div>
                        <select id="shape">
                            <option value="line">Line</option>
                            <option value="round">Round</option>
                            <option value="diamond">Diamond</option>
                            <option value="ellipse">Ellipse</option>
                            <option value="square">Square</option>
                            <option value="cross">Cross</option>
                        </select>
                    </div>
                    
                    <div class="control">
                        <div class="control-header">
                            <label>Frequency</label>
                            <span class="control-value"><span id="frequencyValue">20</span> lpi</span>
                        </div>
                        <input type="range" id="frequency" min="1" max="50" value="20">
                    </div>

                    <div class="control">
                        <div class="control-header">
                            <label>Angle</label>
                            <span class="control-value"><span id="angleValue">90</span>°</span>
                        </div>
                        <input type="range" id="angle" min="0" max="180" value="90">
                    </div>

                    <div class="control">
                        <div class="control-header">
                            <label>Size</label>
                            <span class="control-value"><span id="thicknessValue">1.0</span></span>
                        </div>
                        <input type="range" id="thickness" min="0.3" max="2" step="0.1" value="1">
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Adjustments</div>

                    <div class="control">
                        <div class="control-header">
                            <label>Contrast</label>
                            <span class="control-value"><span id="contrastValue">1.0</span></span>
                        </div>
                        <input type="range" id="contrast" min="0.5" max="2" step="0.1" value="1">
                    </div>

                    <div class="control">
                        <div class="control-header">
                            <label>Brightness</label>
                            <span class="control-value"><span id="brightnessValue">0</span></span>
                        </div>
                        <input type="range" id="brightness" min="-50" max="50" value="0">
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Output</div>
                    
                    <div class="control">
                        <label class="checkbox-control">
                            <input type="checkbox" id="invertOutput">
                            Invert (white lines on black)
                        </label>
                    </div>

                    <div class="control">
                        <label class="checkbox-control">
                            <input type="checkbox" id="transparentBg">
                            Transparent background
                        </label>
                    </div>
                </div>

                <div class="image-info" id="imageInfo"></div>

                <div class="export-section">
                    <div class="section-title">Export</div>
                    <div class="export-options">
                        <div class="export-option" data-scale="1">
                            <div class="scale">1×</div>
                            <div class="label">Original</div>
                        </div>
                        <div class="export-option selected" data-scale="2">
                            <div class="scale">2×</div>
                            <div class="label">High</div>
                        </div>
                        <div class="export-option" data-scale="3">
                            <div class="scale">3×</div>
                            <div class="label">Extra</div>
                        </div>
                        <div class="export-option" data-scale="4">
                            <div class="scale">4×</div>
                            <div class="label">Ultra</div>
                        </div>
                    </div>
                    <button class="export-btn" id="exportBtn" disabled>Export PNG</button>
                </div>
            </div>
        </aside>

        <main class="canvas-area">
            <div class="placeholder" id="placeholder">
                <div class="placeholder-icon">◐</div>
                <p class="placeholder-text">Upload an image to get started</p>
            </div>

            <div class="canvas-container hidden" id="canvasContainer">
                <canvas id="outputCanvas"></canvas>
            </div>

            <div class="processing hidden" id="processing">
                <div class="spinner"></div>
            </div>

            <div class="zoom-controls hidden" id="zoomControls">
                <button class="zoom-btn" id="zoomOut">−</button>
                <span class="zoom-level"><span id="zoomLevel">100</span>%</span>
                <button class="zoom-btn" id="zoomIn">+</button>
                <button class="zoom-btn" id="zoomFit">⊡</button>
            </div>
        </main>
    </div>

    <script>
        // State
        let originalImage = null;
        let greyscaleData = null;
        let currentView = 'halftone';
        let exportScale = 2;
        let zoom = 1;
        let isProcessing = false;

        // DOM elements
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const controls = document.getElementById('controls');
        const placeholder = document.getElementById('placeholder');
        const canvasContainer = document.getElementById('canvasContainer');
        const outputCanvas = document.getElementById('outputCanvas');
        const ctx = outputCanvas.getContext('2d');
        const processing = document.getElementById('processing');
        const zoomControls = document.getElementById('zoomControls');
        const imageInfo = document.getElementById('imageInfo');
        const exportBtn = document.getElementById('exportBtn');

        // Background removal
        const removeBgCheckbox = document.getElementById('removeBg');
        const bgRemovalSettings = document.getElementById('bgRemovalSettings');
        const bgSamplePosition = document.getElementById('bgSamplePosition');
        const bgToleranceSlider = document.getElementById('bgTolerance');
        const bgSoftnessSlider = document.getElementById('bgSoftness');
        
        // Sliders
        const methodSelect = document.getElementById('method');
        const shapeSelect = document.getElementById('shape');
        const halftoneSettings = document.getElementById('halftoneSettings');
        const frequencySlider = document.getElementById('frequency');
        const angleSlider = document.getElementById('angle');
        const thicknessSlider = document.getElementById('thickness');
        const contrastSlider = document.getElementById('contrast');
        const brightnessSlider = document.getElementById('brightness');
        const invertCheckbox = document.getElementById('invertOutput');
        const transparentCheckbox = document.getElementById('transparentBg');

        // Upload handling
        uploadZone.addEventListener('click', () => fileInput.click());
        
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadImage(file);
        });

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    processImage();
                    showControls();
                    updateImageInfo();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function showControls() {
            controls.classList.remove('hidden');
            placeholder.classList.add('hidden');
            canvasContainer.classList.remove('hidden');
            zoomControls.classList.remove('hidden');
            exportBtn.disabled = false;
        }

        function updateImageInfo() {
            const scale = exportScale;
            imageInfo.innerHTML = `
                <span>Original:</span> ${originalImage.width} × ${originalImage.height}px<br>
                <span>Export (${scale}×):</span> ${originalImage.width * scale} × ${originalImage.height * scale}px
            `;
        }

        // Convert to greyscale
        function toGreyscale(imageData) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                // Luminosity method for better perceptual greyscale
                const grey = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                data[i] = data[i + 1] = data[i + 2] = grey;
            }
            return imageData;
        }

        // Apply contrast and brightness
        function adjustLevels(imageData, contrast, brightness) {
            const data = imageData.data;
            const factor = (259 * (contrast * 255 + 255)) / (255 * (259 - contrast * 255));
            
            for (let i = 0; i < data.length; i += 4) {
                for (let j = 0; j < 3; j++) {
                    let value = data[i + j];
                    value = factor * (value - 128) + 128 + brightness;
                    data[i + j] = Math.max(0, Math.min(255, value));
                }
            }
            return imageData;
        }

        // Background removal
        function removeBackground(imageData, width, height, options) {
            const { samplePosition, tolerance, softness } = options;
            const data = imageData.data;
            const output = new ImageData(new Uint8ClampedArray(data), width, height);
            const out = output.data;
            
            // Sample background color from specified position(s)
            let bgR, bgG, bgB;
            
            const samplePixel = (x, y) => {
                const idx = (y * width + x) * 4;
                return { r: data[idx], g: data[idx + 1], b: data[idx + 2] };
            };
            
            if (samplePosition === 'corners') {
                // Average all four corners
                const margin = 5;
                const samples = [
                    samplePixel(margin, margin),
                    samplePixel(width - margin - 1, margin),
                    samplePixel(margin, height - margin - 1),
                    samplePixel(width - margin - 1, height - margin - 1)
                ];
                bgR = Math.round(samples.reduce((s, p) => s + p.r, 0) / 4);
                bgG = Math.round(samples.reduce((s, p) => s + p.g, 0) / 4);
                bgB = Math.round(samples.reduce((s, p) => s + p.b, 0) / 4);
            } else {
                const margin = 5;
                let sample;
                switch (samplePosition) {
                    case 'topleft':
                        sample = samplePixel(margin, margin);
                        break;
                    case 'topright':
                        sample = samplePixel(width - margin - 1, margin);
                        break;
                    case 'bottomleft':
                        sample = samplePixel(margin, height - margin - 1);
                        break;
                    case 'bottomright':
                        sample = samplePixel(width - margin - 1, height - margin - 1);
                        break;
                }
                bgR = sample.r;
                bgG = sample.g;
                bgB = sample.b;
            }
            
            // Calculate alpha for each pixel based on color distance
            const toleranceSquared = (tolerance * 2.55) * (tolerance * 2.55) * 3;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Color distance from background
                const dr = r - bgR;
                const dg = g - bgG;
                const db = b - bgB;
                const distSquared = dr * dr + dg * dg + db * db;
                
                // Calculate alpha based on distance
                let alpha;
                if (distSquared < toleranceSquared) {
                    if (softness > 0) {
                        // Soft edge - gradual falloff
                        const dist = Math.sqrt(distSquared);
                        const maxDist = Math.sqrt(toleranceSquared);
                        const softRange = maxDist * (softness / 5);
                        if (dist < maxDist - softRange) {
                            alpha = 0;
                        } else {
                            alpha = Math.round(((dist - (maxDist - softRange)) / softRange) * 255);
                        }
                    } else {
                        alpha = 0;
                    }
                } else {
                    alpha = 255;
                }
                
                out[i] = r;
                out[i + 1] = g;
                out[i + 2] = b;
                out[i + 3] = alpha;
            }
            
            return output;
        }

        // Store mask for later use
        let backgroundMask = null;

        // 50% Threshold
        function applyThreshold(sourceData, width, height, options) {
            const { invert, transparent, mask } = options;
            const outputData = new ImageData(width, height);
            const src = sourceData.data;
            const dst = outputData.data;
            
            const bgColor = invert ? 0 : 255;
            const fgColor = invert ? 255 : 0;
            const bgAlpha = transparent ? 0 : 255;
            
            for (let i = 0; i < src.length; i += 4) {
                const pixelIdx = i / 4;
                const maskAlpha = mask ? mask[pixelIdx] : 255;
                
                if (maskAlpha === 0) {
                    // Transparent background pixel
                    dst[i] = dst[i + 1] = dst[i + 2] = 0;
                    dst[i + 3] = 0;
                    continue;
                }
                
                const brightness = src[i];
                const isLight = brightness > 127;
                
                if (isLight) {
                    dst[i] = dst[i + 1] = dst[i + 2] = bgColor;
                    dst[i + 3] = mask ? maskAlpha : bgAlpha;
                } else {
                    dst[i] = dst[i + 1] = dst[i + 2] = fgColor;
                    dst[i + 3] = mask ? maskAlpha : 255;
                }
            }
            
            return outputData;
        }

        // Pattern Dither (ordered Bayer matrix)
        function applyPatternDither(sourceData, width, height, options) {
            const { invert, transparent, mask } = options;
            const outputData = new ImageData(width, height);
            const src = sourceData.data;
            const dst = outputData.data;
            
            const bgColor = invert ? 0 : 255;
            const fgColor = invert ? 255 : 0;
            const bgAlpha = transparent ? 0 : 255;
            
            // 4x4 Bayer matrix
            const bayer = [
                [ 0, 8, 2, 10],
                [12, 4, 14, 6],
                [ 3, 11, 1, 9],
                [15, 7, 13, 5]
            ];
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const pixelIdx = y * width + x;
                    const maskAlpha = mask ? mask[pixelIdx] : 255;
                    
                    if (maskAlpha === 0) {
                        dst[idx] = dst[idx + 1] = dst[idx + 2] = 0;
                        dst[idx + 3] = 0;
                        continue;
                    }
                    
                    const brightness = src[idx] / 255;
                    const threshold = (bayer[y % 4][x % 4] + 0.5) / 16;
                    
                    if (brightness > threshold) {
                        dst[idx] = dst[idx + 1] = dst[idx + 2] = bgColor;
                        dst[idx + 3] = mask ? maskAlpha : bgAlpha;
                    } else {
                        dst[idx] = dst[idx + 1] = dst[idx + 2] = fgColor;
                        dst[idx + 3] = mask ? maskAlpha : 255;
                    }
                }
            }
            
            return outputData;
        }

        // Diffusion Dither (Floyd-Steinberg)
        function applyDiffusionDither(sourceData, width, height, options) {
            const { invert, transparent, mask } = options;
            const outputData = new ImageData(width, height);
            const src = sourceData.data;
            const dst = outputData.data;
            
            const bgColor = invert ? 0 : 255;
            const fgColor = invert ? 255 : 0;
            const bgAlpha = transparent ? 0 : 255;
            
            // Copy source to working array
            const pixels = new Float32Array(width * height);
            for (let i = 0; i < pixels.length; i++) {
                pixels[i] = src[i * 4] / 255;
            }
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    
                    // Skip masked pixels
                    if (mask && mask[idx] === 0) continue;
                    
                    const oldPixel = pixels[idx];
                    const newPixel = oldPixel > 0.5 ? 1 : 0;
                    pixels[idx] = newPixel;
                    const error = oldPixel - newPixel;
                    
                    // Distribute error to neighbors (only if not masked)
                    if (x + 1 < width && (!mask || mask[idx + 1] > 0)) 
                        pixels[idx + 1] += error * 7 / 16;
                    if (y + 1 < height) {
                        if (x > 0 && (!mask || mask[idx + width - 1] > 0)) 
                            pixels[idx + width - 1] += error * 3 / 16;
                        if (!mask || mask[idx + width] > 0)
                            pixels[idx + width] += error * 5 / 16;
                        if (x + 1 < width && (!mask || mask[idx + width + 1] > 0)) 
                            pixels[idx + width + 1] += error * 1 / 16;
                    }
                }
            }
            
            // Write output
            for (let i = 0; i < pixels.length; i++) {
                const dstIdx = i * 4;
                const maskAlpha = mask ? mask[i] : 255;
                
                if (maskAlpha === 0) {
                    dst[dstIdx] = dst[dstIdx + 1] = dst[dstIdx + 2] = 0;
                    dst[dstIdx + 3] = 0;
                    continue;
                }
                
                if (pixels[i] > 0.5) {
                    dst[dstIdx] = dst[dstIdx + 1] = dst[dstIdx + 2] = bgColor;
                    dst[dstIdx + 3] = mask ? maskAlpha : bgAlpha;
                } else {
                    dst[dstIdx] = dst[dstIdx + 1] = dst[dstIdx + 2] = fgColor;
                    dst[dstIdx + 3] = mask ? maskAlpha : 255;
                }
            }
            
            return outputData;
        }

        // Halftone Screen with different shapes
        function applyHalftone(sourceData, width, height, options) {
            const { frequency, angle, thickness, shape, invert, transparent, mask } = options;
            
            const outputData = new ImageData(width, height);
            const src = sourceData.data;
            const dst = outputData.data;
            
            // Convert angle to radians - add tiny offset to avoid exact 90/180 degree issues
            let adjustedAngle = angle;
            if (angle % 90 === 0) {
                adjustedAngle = angle + 0.01;
            }
            const angleRad = (adjustedAngle * Math.PI) / 180;
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);
            
            // Calculate cell size based on frequency
            const cellSize = Math.max(2, 72 / frequency);
            
            // Determine colors
            const bgColor = invert ? 0 : 255;
            const fgColor = invert ? 255 : 0;
            const bgAlpha = transparent ? 0 : 255;
            
            // Process each pixel
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const srcIdx = (y * width + x) * 4;
                    const pixelIdx = y * width + x;
                    const maskAlpha = mask ? mask[pixelIdx] : 255;
                    
                    // If masked out, make transparent
                    if (maskAlpha === 0) {
                        dst[srcIdx] = dst[srcIdx + 1] = dst[srcIdx + 2] = 0;
                        dst[srcIdx + 3] = 0;
                        continue;
                    }
                    
                    const brightness = src[srcIdx] / 255;
                    
                    // Rotate coordinates
                    const rx = x * cos + y * sin;
                    const ry = -x * sin + y * cos;
                    
                    // Position within cell (0-1)
                    const cellX = ((rx % cellSize) + cellSize) % cellSize / cellSize;
                    const cellY = ((ry % cellSize) + cellSize) % cellSize / cellSize;
                    
                    // Center of cell
                    const cx = cellX - 0.5;
                    const cy = cellY - 0.5;
                    
                    // Size based on darkness
                    const size = (1 - brightness) * thickness;
                    
                    let isInShape = false;
                    
                    switch (shape) {
                        case 'line':
                            // Horizontal lines (in rotated space)
                            isInShape = Math.abs(cy) < size * 0.5;
                            break;
                            
                        case 'round':
                            // Circle
                            const distRound = Math.sqrt(cx * cx + cy * cy);
                            isInShape = distRound < size * 0.5;
                            break;
                            
                        case 'diamond':
                            // Diamond (rotated square)
                            const distDiamond = Math.abs(cx) + Math.abs(cy);
                            isInShape = distDiamond < size * 0.5;
                            break;
                            
                        case 'ellipse':
                            // Ellipse (wider than tall)
                            const distEllipse = Math.sqrt((cx * cx) / 0.5 + (cy * cy) / 0.2);
                            isInShape = distEllipse < size;
                            break;
                            
                        case 'square':
                            // Square
                            isInShape = Math.abs(cx) < size * 0.4 && Math.abs(cy) < size * 0.4;
                            break;
                            
                        case 'cross':
                            // Cross shape
                            const crossWidth = size * 0.15;
                            const crossLength = size * 0.5;
                            isInShape = (Math.abs(cx) < crossWidth && Math.abs(cy) < crossLength) ||
                                       (Math.abs(cy) < crossWidth && Math.abs(cx) < crossLength);
                            break;
                    }
                    
                    if (isInShape) {
                        dst[srcIdx] = dst[srcIdx + 1] = dst[srcIdx + 2] = fgColor;
                        dst[srcIdx + 3] = mask ? maskAlpha : 255;
                    } else {
                        dst[srcIdx] = dst[srcIdx + 1] = dst[srcIdx + 2] = bgColor;
                        dst[srcIdx + 3] = mask ? maskAlpha : bgAlpha;
                    }
                }
            }
            
            return outputData;
        }

        // Main processing function
        function processImage() {
            if (!originalImage || isProcessing) return;
            
            isProcessing = true;
            processing.classList.remove('hidden');
            
            // Use requestAnimationFrame to allow UI update
            requestAnimationFrame(() => {
                const width = originalImage.width;
                const height = originalImage.height;
                
                // Set canvas size
                outputCanvas.width = width;
                outputCanvas.height = height;
                
                // Draw original image
                ctx.drawImage(originalImage, 0, 0);
                
                // Get image data
                let imageData = ctx.getImageData(0, 0, width, height);
                
                // Remove background if enabled (do this first, before greyscale)
                if (removeBgCheckbox.checked) {
                    const bgOptions = {
                        samplePosition: bgSamplePosition.value,
                        tolerance: parseInt(bgToleranceSlider.value),
                        softness: parseInt(bgSoftnessSlider.value)
                    };
                    imageData = removeBackground(imageData, width, height, bgOptions);
                    // Store the alpha channel as our mask
                    backgroundMask = new Uint8Array(width * height);
                    for (let i = 0; i < backgroundMask.length; i++) {
                        backgroundMask[i] = imageData.data[i * 4 + 3];
                    }
                } else {
                    backgroundMask = null;
                }
                
                // Convert to greyscale
                imageData = toGreyscale(imageData);
                
                // Apply contrast and brightness
                const contrast = (parseFloat(contrastSlider.value) - 1);
                const brightness = parseInt(brightnessSlider.value);
                imageData = adjustLevels(imageData, contrast, brightness);
                
                // Store greyscale data for view switching
                greyscaleData = new ImageData(
                    new Uint8ClampedArray(imageData.data),
                    width,
                    height
                );
                
                if (currentView === 'halftone') {
                    // Apply selected method
                    const method = methodSelect.value;
                    const options = {
                        frequency: parseFloat(frequencySlider.value),
                        angle: parseFloat(angleSlider.value),
                        thickness: parseFloat(thicknessSlider.value),
                        shape: shapeSelect.value,
                        invert: invertCheckbox.checked,
                        transparent: transparentCheckbox.checked,
                        mask: backgroundMask
                    };
                    
                    switch (method) {
                        case 'threshold':
                            imageData = applyThreshold(greyscaleData, width, height, options);
                            break;
                        case 'pattern':
                            imageData = applyPatternDither(greyscaleData, width, height, options);
                            break;
                        case 'diffusion':
                            imageData = applyDiffusionDither(greyscaleData, width, height, options);
                            break;
                        case 'halftone':
                        default:
                            imageData = applyHalftone(greyscaleData, width, height, options);
                            break;
                    }
                } else if (currentView === 'original') {
                    // Redraw original
                    ctx.drawImage(originalImage, 0, 0);
                    isProcessing = false;
                    processing.classList.add('hidden');
                    updateZoom();
                    return;
                }
                
                // Put processed data back
                ctx.putImageData(imageData, 0, 0);
                
                isProcessing = false;
                processing.classList.add('hidden');
                updateZoom();
            });
        }

        // Debounced processing
        let processTimeout;
        function debouncedProcess() {
            clearTimeout(processTimeout);
            processTimeout = setTimeout(processImage, 50);
        }

        // Slider updates
        function setupSlider(slider, valueEl, suffix = '') {
            slider.addEventListener('input', () => {
                valueEl.textContent = slider.value;
                debouncedProcess();
            });
        }

        setupSlider(frequencySlider, document.getElementById('frequencyValue'));
        setupSlider(angleSlider, document.getElementById('angleValue'));
        setupSlider(thicknessSlider, document.getElementById('thicknessValue'));
        setupSlider(contrastSlider, document.getElementById('contrastValue'));
        setupSlider(brightnessSlider, document.getElementById('brightnessValue'));
        setupSlider(bgToleranceSlider, document.getElementById('bgToleranceValue'));
        setupSlider(bgSoftnessSlider, document.getElementById('bgSoftnessValue'));

        removeBgCheckbox.addEventListener('change', () => {
            bgRemovalSettings.classList.toggle('hidden', !removeBgCheckbox.checked);
            debouncedProcess();
        });
        bgSamplePosition.addEventListener('change', debouncedProcess);

        methodSelect.addEventListener('change', () => {
            // Show/hide halftone settings based on method
            halftoneSettings.style.display = methodSelect.value === 'halftone' ? 'block' : 'none';
            debouncedProcess();
        });
        
        shapeSelect.addEventListener('change', debouncedProcess);
        invertCheckbox.addEventListener('change', debouncedProcess);
        transparentCheckbox.addEventListener('change', debouncedProcess);

        // View toggle
        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentView = btn.dataset.view;
                processImage();
            });
        });

        // Export scale options
        document.querySelectorAll('.export-option').forEach(opt => {
            opt.addEventListener('click', () => {
                document.querySelectorAll('.export-option').forEach(o => o.classList.remove('selected'));
                opt.classList.add('selected');
                exportScale = parseInt(opt.dataset.scale);
                updateImageInfo();
            });
        });

        // Export
        exportBtn.addEventListener('click', () => {
            if (!originalImage) return;
            
            processing.classList.remove('hidden');
            
            requestAnimationFrame(() => {
                const scale = exportScale;
                const width = originalImage.width * scale;
                const height = originalImage.height * scale;
                
                // Create high-res canvas
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = width;
                exportCanvas.height = height;
                const exportCtx = exportCanvas.getContext('2d');
                
                // Draw scaled original
                exportCtx.drawImage(originalImage, 0, 0, width, height);
                
                // Get image data
                let imageData = exportCtx.getImageData(0, 0, width, height);
                
                // Remove background if enabled
                let exportMask = null;
                if (removeBgCheckbox.checked) {
                    const bgOptions = {
                        samplePosition: bgSamplePosition.value,
                        tolerance: parseInt(bgToleranceSlider.value),
                        softness: parseInt(bgSoftnessSlider.value)
                    };
                    imageData = removeBackground(imageData, width, height, bgOptions);
                    exportMask = new Uint8Array(width * height);
                    for (let i = 0; i < exportMask.length; i++) {
                        exportMask[i] = imageData.data[i * 4 + 3];
                    }
                }
                
                // Process
                imageData = toGreyscale(imageData);
                const contrast = (parseFloat(contrastSlider.value) - 1);
                const brightness = parseInt(brightnessSlider.value);
                imageData = adjustLevels(imageData, contrast, brightness);
                
                if (currentView === 'halftone') {
                    // Apply selected method with scaled frequency
                    const method = methodSelect.value;
                    const options = {
                        frequency: parseFloat(frequencySlider.value) / scale,
                        angle: parseFloat(angleSlider.value),
                        thickness: parseFloat(thicknessSlider.value),
                        shape: shapeSelect.value,
                        invert: invertCheckbox.checked,
                        transparent: transparentCheckbox.checked,
                        mask: exportMask
                    };
                    
                    switch (method) {
                        case 'threshold':
                            imageData = applyThreshold(imageData, width, height, options);
                            break;
                        case 'pattern':
                            imageData = applyPatternDither(imageData, width, height, options);
                            break;
                        case 'diffusion':
                            imageData = applyDiffusionDither(imageData, width, height, options);
                            break;
                        case 'halftone':
                        default:
                            imageData = applyHalftone(imageData, width, height, options);
                            break;
                    }
                }
                
                exportCtx.putImageData(imageData, 0, 0);
                
                // Download
                const link = document.createElement('a');
                link.download = `halftone-${scale}x.png`;
                link.href = exportCanvas.toDataURL('image/png');
                link.click();
                
                processing.classList.add('hidden');
            });
        });

        // Zoom controls
        function updateZoom() {
            outputCanvas.style.transform = `scale(${zoom})`;
            outputCanvas.style.transformOrigin = 'center center';
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100);
        }

        document.getElementById('zoomIn').addEventListener('click', () => {
            zoom = Math.min(zoom * 1.25, 4);
            updateZoom();
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            zoom = Math.max(zoom / 1.25, 0.25);
            updateZoom();
        });

        document.getElementById('zoomFit').addEventListener('click', () => {
            zoom = 1;
            updateZoom();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === '+' || e.key === '=') {
                zoom = Math.min(zoom * 1.25, 4);
                updateZoom();
            } else if (e.key === '-') {
                zoom = Math.max(zoom / 1.25, 0.25);
                updateZoom();
            } else if (e.key === '0') {
                zoom = 1;
                updateZoom();
            }
        });
    </script>
</body>
</html>
